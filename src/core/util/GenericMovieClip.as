import core.util.Utils;

/*
 * extends core.util.GenericMovieClip to provide a generic movie clip
 * with more functions (particularly for animation). 
 * 
 * All components should extend this generic clip instead of
 * MovieClip
 * 
 * @author Max Pimm
 * @created 09-09-2005
 * @version 1.0
 */
dynamic class core.util.GenericMovieClip extends MovieClip{
	
	/*
	 * Constructor
	 */
	public function GenericMovieClip(){
	}
	
	/*
	 * Overwrittes super method so that sub clips generated by GenericMovieClips will
	 * also be GenericMovieClips
	 */
	public function createEmptyMovieClip(id:String, depth:Number):GenericMovieClip{
		return Utils.newObject(GenericMovieClip, this, id, depth);
	}
	
	/*
	 * Glides the movie clip to a new location. Starts fast and eases out
	 * 
	 * @param x the new x coordinate
	 * @param y the new y coordinate
	 * @param speed the speed, factor by which the distance to be travelled
	 * is divided in each iteration. ie 1 = does not move and 2 = distance halved
	 * with every iteration
	 * @param callBackFunc a function to be called when the amimations ends
	 */
	public function glideTo(x:Number, y:Number, speed:Number, callBackFunc:Function):Void{
		
		//remove clip if exists, stops any previous animation
		this["move_mc"].removeMovieClip();
		
		//create new clip
		var move_mc:MovieClip = this.createEmptyMovieClip('move_mc', this["getNextHighestDepth"]());
		
		//asign dynamic properties to new clip
		move_mc.x = x;
		move_mc.y = y;
		move_mc.speed = speed;
		move_mc.callBackFunc = callBackFunc;
		
		//create animation
		move_mc.onEnterFrame = function() {
			this._parent._x += (x-this._parent._x)/speed;
			this._parent._y += (y-this._parent._y)/speed;
			if ((Math.abs(x-this._parent._x)<1) && (Math.abs(y-this._parent._y)<1)) {
				this._parent._x = x;
				this._parent._y = y;
				this._parent.done
				this.callBackFunc();
				delete this.onEnterFrame;
				this.removeMovieClip();
			}
		};
	};
	
	
	/*
	 * Moves the movie clip to a new location at a constant speed
	 * 
	 * @param x the new x coordinate
	 * @param y the new y coordinate
	 * @param frames the speed, the number of frames in which to complete the movement
	 * @param callBackFunc a function to be called when the amimations ends
	 */
	public function shiftTo(x:Number, y:Number, frames:Number, callBackFunc:Function):Void{
		
		//remove clip if exists, stops any previous animation
		this["shift_mc"].removeMovieClip();
		
		//create new clip
		var shift_mc:MovieClip = this.createEmptyMovieClip('shift_mc', this["getNextHighestDepth"]());
		
		//asign dynamic properties to new clip
		shift_mc.x = x;
		shift_mc.y = y;
		shift_mc.frameCnt = 1;
		shift_mc.frames = frames;
		shift_mc.xPerFrame = (x-this._x)/frames;
		shift_mc.yPerFrame = (y-this._y)/frames;
		shift_mc.callBackFunc = callBackFunc;
		
		//create animation
		shift_mc.onEnterFrame = function() {
			this._parent._x += this.xPerFrame;
			this._parent._y += this.yPerFrame;
			if (this.frameCnt == this.frames) {
				this._parent._x = this.x;
				this._parent._y = this.y;
				this.callBackFunc();
				delete this.onEnterFrame;
				this.removeMovieClip();
			} else {
				this.frameCnt++;
			}
		};
	};
	
	/*
	 * Dynamic alpha tween
	 * @param alpha the final alpha
	 * @param frames the number of frames used to make the transition. The transition is linear.
	 * @param callbackFunc a function to be called when the animation ends
	 */
	public function alphaTo(alpha:Number, frames:Number, callBackFunc:Function):Void{
		
		//remove clip if exists, stops any previous animation
		this["alpha_mc"].removeMovieClip();
		
		//create new clip
		var alpha_mc:MovieClip = this.createEmptyMovieClip('alpha_mc', this["getNextHighestDepth"]());
		
		//asign dynamic properties to new clip
		alpha_mc.alpha = alpha;
		alpha_mc.frames = frames;
		alpha_mc.frameCnt = 1;
		alpha_mc.aperframe = (alpha-this._alpha)/frames;
		alpha_mc.callBackFunc = callBackFunc;
		
		alpha_mc.onEnterFrame = function() {
			this._parent._alpha += this.aperframe;
			if (this.frameCnt == this.frames) {
				this._parent._alpha = this.alpha;
				this.callBackFunc();
				delete this.onEnterFrame;
				this.removeMovieClip();
			} else {
				this.frameCnt++;
			}
		};
	};
	
	/*
	 * Dynamically scales clip
	 * 
	 * @param xscale the new xscale of the clip
	 * @param yscale the new yscale of the clip
	 * @param speed the speed, factor by which the scale to be increased/decreased
	 * is divided in each iteration. ie 1 = does not change scale and 2 = scale halved
	 * with every iteration
	  * @param callBackFunc a function to be called when the amimations ends
	 */
	public function scaleTo (xscale:Number, yscale:Number, speed:Number, callBackFunc:Function) {
	
		//remove clip if exists, stops any previous animation
		this["scale_mc"].removeMovieClip();
		
		//create new clip
		var scale_mc:MovieClip = this.createEmptyMovieClip('scale_mc', this["getNextHighestDepth"]());
		
		//asign dynamic properties to new clip
		scale_mc.xscale = xscale;
		scale_mc.yscale = yscale;
		scale_mc.speed = speed;
		scale_mc.callBackFunc = callBackFunc;
		scale_mc.xInc = (xscale-this._xscale)/speed; 
		scale_mc.yInc = (yscale-this._yscale)/speed; 
		
		//create animation
		scale_mc.onEnterFrame = function() {
			//this._parent._xscale += (xscale-this._parent._xscale)/speed;
			//this._parent._yscale += (yscale-this._parent._yscale)/speed;
			this._parent._xscale += this.xInc;
			this._parent._yscale += this.yInc;
			if ((Math.abs(xscale-this._parent._xscale)<0.4) && (Math.abs(yscale-this._parent._yscale)<0.4)) {
				this._parent._xscale = xscale;
				this._parent._yscale = yscale;
				this.callBackFunc();
				this.removeMovieClip();
				delete this.onEnterFrame;
		}
	};
};
	
	/*
	 * Draws a shape in the clip
	 * @param id the of the clip that the shape will be drawn in
	 * @param depth the depth of the clip that the shape will be drawn in
	 * @param x the relative x coordinate of the shape
	 * @param y the relative y coordinate of the shape
	 * @param coords an array of coordinates that defines the shape
	 * @param line an array of three elements [thickness, rgb, alpha] that define the line style
	 * @param fill an array of 2 elements [rgb, alpha] that define the fill style
	 */
	public function drawShape(id:String, depth:Number, x:Number, y:Number, coords:Array, line:Array, fill:Array):Void{
		this.createEmptyMovieClip(id, depth);
		this[id]._x = x;
		this[id]._y = y;
		this[id].lineStyle(line[0], line[1], line[2]);
		this[id].moveTo(coords[0][0], coords[0][1]);
		if (fill) {
			this[id].beginFill(fill[0], fill[1]);
		}
		for (var i = 1; i<coords.length; i++) {
			this[id].lineTo(coords[i][0], coords[i][1]);
		}
		if (fill) {
			this[id].endFill();
		}
	};

	/*
	 * Draws a circle in the clip. Line style and fill style should
	 * have been defined before hand. Unlike drawShape this method does
	 * not create the shape in a sub clip but draws it the clip itself
	 * 
	 * @param x the relative x coordinate of the circle
	 * @param y the relative y coordinate of the circle
	 * @param radius the dimensions in pixels of the radius
	 * @param acuracy the number of curves used to make the circle
	 */
	public function drawCircle(x, y, radius, accuracy):Void{
		if (accuracy<3) {
			accuracy = 3;
		}
		var span = Math.PI/accuracy;
		var controlRadius = radius/Math.cos(span);
		var anchorAngle = 0, controlAngle = 0;
		this.moveTo(x+Math.cos(anchorAngle)*radius, y+Math.sin(anchorAngle)*radius);
		for (var i = 0; i<accuracy; ++i) {
			controlAngle = anchorAngle+span;
			anchorAngle = controlAngle+span;
			this.curveTo(x+Math.cos(controlAngle)*controlRadius, y+Math.sin(controlAngle)*controlRadius, x+Math.cos(anchorAngle)*radius, y+Math.sin(anchorAngle)*radius);
		}
	};
	
	/*
	 * Dynamically sets any property of the clip. Allows properties
	 * to be set via method calls
	 * 
	 * @param propName the identifier of the property
	 * @param propValue the new value of the property
	 */
	public function setProperty(propName:String, propValue:Object){
		this[propName] = propValue
		
	}
}